# Copyright (c) 2018, 2019 Oracle and/or its affiliates. All rights reserved. This
# code is released under a tri EPL/GPL/LGPL license. You can use it,
# redistribute it and/or modify it under the terms of the:
#
# Eclipse Public License version 2.0, or
# GNU General Public License version 2, or
# GNU Lesser General Public License version 2.1.

require_relative '../../ruby/spec_helper'
require_relative 'fixtures/classes.rb'

output = [<<HEADER]
<!-- Generated by spec/truffle/interop/special_forms_spec.rb -->

# Implicit Polyglot API

In the documentation below:
* `name` is a `String` or `Symbol`.
* `index` is an `Integer`.

Format: `Ruby code` sends `InteropLibrary message`

HEADER

describe "Interop special forms" do

  before :each do
    @object = Truffle::Interop.logging_foreign_object
  end

  after :all do
    file = File.expand_path('../../../doc/contributor/interop_implicit_api.md', __dir__)
    File.open(file, 'w') do |out|
      output.each do |line|
        out.puts line
      end
    end
  end

  doc = -> form, result do
    string = "`foreign_object#{form}` #{result}"
    output << "- #{string}"
    string
  end

  description = -> form, method, arguments = [], condition = nil do
    result = "sends `#{method}(#{[:foreign_object, *arguments].join(', ')})`"
    result += " #{condition}" if condition
    doc[form, result]
  end

  # TODO (pitr-ch 23-Mar-2020): test what method has a precedence, special or the invokable-member on the foreign object
  # TODO (pitr-ch 23-Mar-2020): test left side operator conversion with asBoolean, asString, etc.

  it description['[name]', :readMember, [:name]] do
    -> { @object[:foo] }.should raise_error(Polyglot::UnsupportedMessageError)
    -> { @object['bar'] }.should raise_error(Polyglot::UnsupportedMessageError)
    Truffle::Interop.to_display_string(@object).should include("readMember(foo)")
    Truffle::Interop.to_display_string(@object).should include("readMember(bar)")
  end

  it description['[index]', :readArrayElement, [:index]] do
    -> { @object[0] }.should raise_error(Polyglot::UnsupportedMessageError)
    Truffle::Interop.to_display_string(@object).should include("readArrayElement(0)")
  end

  it description['[name] = value', :writeMember, [:name, :value]] do
    -> { (@object[:foo] = 1) }.should raise_error(Polyglot::UnsupportedMessageError)
    -> { (@object['bar'] = 2) }.should raise_error(Polyglot::UnsupportedMessageError)
    Truffle::Interop.to_display_string(@object).should include("writeMember(foo, 1)")
    Truffle::Interop.to_display_string(@object).should include("writeMember(bar, 2)")
  end

  it description['[index] = value', :writeArrayElement, [:index, :value]] do
    -> { (@object[0] = 1) }.should raise_error(Polyglot::UnsupportedMessageError)
    Truffle::Interop.to_display_string(@object).should include("writeArrayElement(0, 1)")
  end

  it description['.name = value', :writeMember, [:name, :value]] do
    pm = TruffleInteropSpecs::PolyglotMember.new
    pfo = Truffle::Interop.proxy_foreign_object(pm)
    pfo.foo = :bar
    messages = pm.log
    messages.should include([:polyglot_write_member, "foo", :bar])
  end

  it description['.name = *arguments', :writeMember, [:name, 'arguments']] do
    pm = TruffleInteropSpecs::PolyglotMember.new
    pfo = Truffle::Interop.proxy_foreign_object(pm)
    pfo.foo = :bar, :baz
    messages = pm.log
    messages.should include([:polyglot_write_member, "foo", [:bar, :baz]])
  end

  it "raises an argument error if an assignment method is called with more than 1 argument" do
    pm = TruffleInteropSpecs::PolyglotMember.new
    pfo = Truffle::Interop.proxy_foreign_object(pm)
    -> { pfo.__send__(:foo=, :bar, :baz) }.should raise_error(ArgumentError)
  end

  it description['.delete(name)', :removeMember, [:name]] do
    -> { @object.delete :foo }.should raise_error(Polyglot::UnsupportedMessageError)
    Truffle::Interop.to_display_string(@object).should include("removeMember(foo)")
  end

  it description['.delete(index)', :removeArrayElement, [:index]] do
    -> { @object.delete 14 }.should raise_error(Polyglot::UnsupportedMessageError)
    Truffle::Interop.to_display_string(@object).should include("removeArrayElement(14)")
  end

  it description['.call(*arguments)', :execute, ['*arguments']] do
    -> { @object.call(1, 2, 3) }.should raise_error(Polyglot::UnsupportedMessageError)
    Truffle::Interop.to_display_string(@object).should include("execute(1, 2, 3)")
  end

  it description['.nil?', :isNull] do
    @object.nil?
    Truffle::Interop.to_display_string(@object).should include("isNull()")
  end

  it description['.size', :getArraySize] do
    -> { @object.size }.should raise_error(Polyglot::UnsupportedMessageError)
    Truffle::Interop.to_display_string(@object).should include("getArraySize()")
  end

  it description['.keys', :getMembers] do
    -> { @object.keys }.should raise_error(Polyglot::UnsupportedMessageError)
    Truffle::Interop.to_display_string(@object).should include("getMembers(false)")
  end

  it description['.method_name', :invoke_member, ['method_name']] do
    -> { @object.foo }.should raise_error(Polyglot::UnsupportedMessageError)
    Truffle::Interop.to_display_string(@object).should include("invokeMember(foo)")
  end

  it description['.method_name(*arguments)', :invoke_member, ['method_name', '*arguments']] do
    -> { @object.bar(1, 2, 3) }.should raise_error(Polyglot::UnsupportedMessageError)
    Truffle::Interop.to_display_string(@object).should include("invokeMember(bar, 1, 2, 3)")
  end

  it description['.method_name(*arguments) &block', :invoke_member, ['method_name', '*arguments, block']] do
    pm = TruffleInteropSpecs::PolyglotMember.new
    pfo = Truffle::Interop.proxy_foreign_object(pm)
    block = Proc.new {}
    pfo.foo = -> *x { 1 }
    pfo.foo(1, 2, 3, &block)
    messages = pm.log
    messages.should include([:polyglot_invoke_member, "foo", 1, 2, 3, block])
  end

  it description['.new(*arguments)', :instantiate, ['*arguments']] do
    -> { @object.new }.should raise_error(Polyglot::UnsupportedMessageError)
    Truffle::Interop.to_display_string(@object).should include("instantiate()")
  end

  guard -> { !TruffleRuby.native? } do
    it description['.class', :readMember, ['"class"'], 'when `foreign_object` is a `java.lang.Class`'] do
      Java.type('java.math.BigInteger').class.getName.should == 'java.math.BigInteger'
    end
  end

  it description['.class', :getMetaObject] do
    @object.class.should == Truffle::Interop::Foreign
    Truffle::Interop.to_display_string(@object).should include("hasMetaObject()")
  end

  it doc['.inspect', 'returns a Ruby-style `#inspect` string showing members, array elements, etc'] do
    # More detailed specs in spec/truffle/interop/foreign_inspect_to_s_spec.rb
    @object.inspect.should =~ /\A#<Foreign:0x\h+>\z/
  end

  it description['.to_s', :asString, [], 'when `isString(foreign_object)` is true'] do
    @object = Truffle::Interop.logging_foreign_object("asString contents")
    @object.to_s.should == "asString contents"
    Truffle::Interop.to_display_string(@object).should include("asString()")
  end

  it description['.to_s', :toDisplayString, [], 'otherwise'] do
    @object.to_s.should include("toDisplayString(")
  end

  it description['.to_str', :asString, [], 'when `isString(foreign_object)` is true'] do
    @object = Truffle::Interop.logging_foreign_object("asString contents")
    @object.to_str.should == "asString contents"
    Truffle::Interop.to_display_string(@object).should include("isString()")
    Truffle::Interop.to_display_string(@object).should include("asString()")
  end

  it doc['.to_str', 'raises `NoMethodError` otherwise'] do
    -> { @object.to_str }.should raise_error(NoMethodError)
  end

  it doc['.to_a', 'converts to a Ruby `Array` with `Truffle::Interop.to_array(foreign_object)`'] do
    -> { @object.to_a }.should raise_error(RuntimeError)
    Truffle::Interop.to_display_string(@object).should include("hasArrayElements()")
  end

  it doc['.to_ary', 'converts to a Ruby `Array` with `Truffle::Interop.to_array(foreign_object)`'] do
    -> { @object.to_a }.should raise_error(RuntimeError)
    Truffle::Interop.to_display_string(@object).should include("hasArrayElements()")
  end

  output << "\nUse `.respond_to?` for calling `InteropLibrary` predicates:\n"

  it doc['.respond_to?(:inspect)', "is always true"] do
    @object.respond_to?(:inspect).should be_true
  end

  it doc['.respond_to?(:to_s)', "is always true"] do
    @object.respond_to?(:to_s).should be_true
  end

  it description['.respond_to?(:to_str)', :isString] do
    @object.respond_to?(:to_str)
    Truffle::Interop.to_display_string(@object).should include("isString()")
  end

  it description['.respond_to?(:to_a)', :hasArrayElements] do
    @object.respond_to?(:to_a)
    Truffle::Interop.to_display_string(@object).should include("hasArrayElements()")
  end

  it description['.respond_to?(:to_ary)', :hasArrayElements] do
    @object.respond_to?(:to_ary)
    Truffle::Interop.to_display_string(@object).should include("hasArrayElements()")
  end

  it description['.respond_to?(:size)', :hasArrayElements] do
    @object.respond_to?(:size)
    Truffle::Interop.to_display_string(@object).should include("hasArrayElements()")
  end

  it description['.respond_to?(:keys)', :hasMembers] do
    @object.respond_to?(:keys)
    Truffle::Interop.to_display_string(@object).should include("hasMembers()")
  end

  it description['.respond_to?(:call)', :isExecutable] do
    @object.respond_to?(:call)
    Truffle::Interop.to_display_string(@object).should include("isExecutable()")
  end

  it description['.respond_to?(:new)', :isInstantiable] do
    @object.respond_to?(:new)
    Truffle::Interop.to_display_string(@object).should include("isInstantiable()")
  end

  it doc['.respond_to?(:is_a?)', "is always true"] do
    @object.respond_to?(:is_a?).should be_true
  end

  describe "#is_a?" do

    it "returns false for a non-Java foreign object and a Ruby class" do
      Truffle::Debug.foreign_object.is_a?(Hash).should be_false
    end

    guard -> { !TruffleRuby.native? } do
      it "returns false for Java null" do
        big_integer_class = Truffle::Interop.java_type("java.math.BigInteger")
        Truffle::Debug.java_null.is_a?(big_integer_class).should be_false
      end

      it "returns true for a directly matching Java object and class" do
        big_integer_class = Truffle::Interop.java_type("java.math.BigInteger")
        big_integer = big_integer_class.new("14")
        big_integer.is_a?(big_integer_class).should be_true
      end

      it "returns true for a directly matching Java object and superclass" do
        big_integer_class = Truffle::Interop.java_type("java.math.BigInteger")
        big_integer = big_integer_class.new("14")
        number_class = Truffle::Interop.java_type("java.lang.Number")
        big_integer.is_a?(number_class).should be_true
      end

      it "returns true for a directly matching Java object and interface" do
        big_integer_class = Truffle::Interop.java_type("java.math.BigInteger")
        big_integer = big_integer_class.new("14")
        serializable_interface = Truffle::Interop.java_type("java.io.Serializable")
        big_integer.is_a?(serializable_interface).should be_true
      end

      it "returns false for an unrelated Java object and Java class" do
        big_integer_class = Truffle::Interop.java_type("java.math.BigInteger")
        big_integer = big_integer_class.new("14")
        big_decimal_class = Truffle::Interop.java_type("java.math.BigDecimal")
        big_integer.is_a?(big_decimal_class).should be_false
      end

      it "returns false for a Java object and a Ruby class" do
        java_hash = Truffle::Interop.java_type("java.util.HashMap").new
        java_hash.is_a?(Hash).should be_false
      end

      it "raises a type error for a non-Java foreign object and a non-Java foreign class" do
        -> {
          Truffle::Debug.foreign_object.is_a?(Truffle::Debug.foreign_object)
        }.should raise_error(TypeError, /cannot check if a foreign object is an instance of a foreign class/)
      end

      it "works with boxed primitives" do
        boxed_integer = Truffle::Debug.foreign_boxed_value(14)
        boxed_integer.is_a?(Integer).should be_true
        boxed_double = Truffle::Debug.foreign_boxed_value(14.2)
        boxed_double.is_a?(Float).should be_true
      end
    end
  end
end
